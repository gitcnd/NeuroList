use ExtUtils::MakeMaker;
# See lib/ExtUtils/MakeMaker.pm for details of how to influence
# the contents of the Makefile that is written.
WriteMakefile(
    NAME              => 'NeuroList',
    VERSION_FROM      => 'lib/NeuroList.pm', # finds $VERSION, requires EU::MM from perl >= 5.5
    PREREQ_PM         => {}, # e.g., Module::Name => 1.1
    ABSTRACT_FROM     => 'lib/NeuroList.pm', # retrieve abstract from module
    AUTHOR            => 'Chris Drake <cdrake@cpan.org>',
    #LICENSE           => 'perl',
    #Value must be from legacy list of licenses here
    #http://search.cpan.org/perldoc?Module%3A%3ABuild%3A%3AAPI
);


sub MY::postamble {
    my $self = shift;
    my $abstract_from = $self->{ABSTRACT_FROM};

    my $abstract_from_esc = $abstract_from;
    $abstract_from_esc =~ s{\\}{\\\\}g;  # Escape backslashes if any
    $abstract_from_esc =~ s{"}{\\"}g;    # Escape double quotes

    my ($mod_name)=($abstract_from=~/([A-Za-z0-9\-]+)\.pm/);
    $mod_name=~s/-/::/g;

    my $version = MM->parse_version($abstract_from);
    my $escaped_version = $version;
    $escaped_version =~ s{\\}{\\\\}g;
    $escaped_version =~ s{"}{\\"}g;

    my $ver="$mod_name version $version";
    my $veru='=' x (length $ver);

# \t\$(PERL) -e "open my \\\$in, '<', 'README' or die \\\$!; my \\\$content = do { local \\\$/; <\\\$in> }; close \\\$in; \\\$content =~ s/^NAME\\n.*?\\n\\n//s; open my \\\$out, '>', 'README' or die \\\$!; print \\\$out qq{$escaped_module_name version $escaped_version\\n===========================\\n\\n}; print \\\$out \\\$content; close \\\$out;"

#\t\$(PERL) -e 'open FH, ">>", "README"    or die \$!; print FH qq{\\nCaution; this file is autogenerated from $abstract_from_esc v$escaped_version and will be overwritten upon "make".\\n}; close FH;'
# \t\$(PERL) -i -pe "BEGIN { print qq{$escaped_module_name version $escaped_version\\n===========================\\n\\n}; } s/^NAME\\n.*?\\n\\n//s if \$. == 1;" README
# \t\$(PERL) -e 'open FH, "<",  "README"    or die \$!; my \\\$content = do { local \$/; <FH> }; close FH; \$content =~ s/^NAME/\$ver\\n\$veru\\n\\n/s; open FH ">", "README" or die \$!; print FH \$content . "\\nCaution; this file is autogenerated from $abstract_from_esc v$escaped_version and will be overwritten upon \\"make\\".\\n" ; close FH;'
#\t\$(PERL) -i -pe 'BEGIN {print qq{$ver\\n$veru\\n}; } s/^NAME\\n.*?//s ; END{print qq{\\n\\nCaution; this file is autogenerated from $abstract_from_esc v$escaped_version and will be overwritten upon "make"._\\n}}' README

    return qq{
all :: generate_readme

generate_readme:
\t\$(PERL) -MPod::Markdown -e "Pod::Markdown->new->filter(\@ARGV)" $abstract_from > README.md
\t\$(PERL) -MPod::Text -e "Pod::Text->new->filter(\@ARGV)" $abstract_from > README
\t\$(PERL) -e 'open FH, ">>", "README.md" or die \$!; print FH qq{\\n_Caution; this file is autogenerated from $abstract_from_esc v$escaped_version and will be overwritten upon "make"._\\n}; close FH;'
\t\$(PERL) -e 'open FH, ">>", "README"    or die \$!; print FH qq{\\nCaution; this file is autogenerated from $abstract_from_esc v$escaped_version and will be overwritten upon "make".\\n}; close FH;'
\t\$(PERL) -i -pe 's/^NAME\\n.*?/$ver\\n$veru\\n\\n/s;' README

}#qq

}

